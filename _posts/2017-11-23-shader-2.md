---
layout: single
title: "Shader ใน LibGDX เบื้องต้น ตอนที่ 2"
categories: "Shader"
---

ต่อจากตอนที่แล้ว เราลองเขียนโปรแกรม shader ทีเปลี่ยนสี pixel ทั้งหมดเป็นสีแดงแล้ว ในตอนนี้เราจะลองมาเขียนโปรแกรม shader ที่เป็น default shader กัน


## ลองสร้าง Default shader

default shader คือ shader ที่ไม่ได้ตกแต่งภาพอะไรเพิ่มเติมเลย ก่อนอื่นเริ่มจากเขียน vertex shader ก่อน โดยเขียนเหมือนกับอันที่แล้ว

`shader-default.vert`

```c
uniform mat4 u_projTrans;

attribute vec4 a_position;

void main() {
    gl_Position = u_projTrans * a_position;
}
```

ทีนี้เราต้องส่งข้อมูล texture ไปให้กับ fragment shader ด้วย ซึ่งข้อมูล texture จะส่งมาในรูปของระบบพิกัด texture โดยที่
ระบบพิกัดของ texture จะใช้ระบบแบบ 2 มิติ คือระบบ ST มีค่าตั้งแต่ (0, 0) ไปถึง (1, 1) ตามรูป 

![](https://lh3.googleusercontent.com/hDgBZwf2am9DV6TGH4AhgyiRF4UXMy8OF_pOHbxIMOG8Kqw4I2Cu0ZZBNr9zD5sZNWFsepjAX9SJtQMPzSjY5chjjO_Qf8vwK4wRv7Z8G51jNJhgwJtZpgQ0rSCX5j9yIUtSXPUSt4ppkMSMGke-KcHu5oNwFxEbxD4j1K0xAoC-ntCygvItCLimO-HLMrPWHR11-3UIjZNvdyLBBJo8fqwb298tZlbaYwz-7bxz_eOa_k_BRw3oyUwNhM813FKI5Zs3gwFqeQ0zpTFDGYL065ZousILALl_vWb9yz4Qf830OYBn-kn1kGQKJGTOMlHPBLlh_BTYUgFfWe03vTvduEe1C-o2KET19xmkkTyZquOHv5vTqaw8xfiMQtV9Wqkn1ZDvAbDb9JeKiNQxkAYCIGP0eEQ-hKTqBQfBG1A6Hs22CBMxHKCGFdGxefyKR9sCa3ksG8txywQ4OwAYf5ctVL28BCWSBeO9Q9F5QA3cA0jK2ZgbpbCp0GC_EL3s_a_st8Okd1Nw_yVQzjVGU1IejJw9Cxn_92WSNLJVl2t01n7U5PIn40RMNAhH9bheCqv_Gie7E6Y-bLCLbJr62DSGgSrr8vEJCqke6NuC52cwVA=w365-h398-no)

ดังนั้นตัวแปรจะมีชนิด `vec2` และ libGDX framework จะส่งค่ามาให้กับตัวแปรที่ชื่อ `a_texCoord0` ดังนั้น จะเขียน code ได้ดังนี้


`shader-default.vert`

```c
uniform mat4 u_projTrans;

attribute vec4 a_position;
attribute vec2 a_texCoord0;

void main() {
    gl_Position = u_projTrans * a_position;
}
```
 
สังเกตว่า `a_texCoord0` เป็นตัวแปรแบบ `attribute` ด้วย เพราะเป็นข้อมูลที่อยู่ใน `buffer object`

จากนั้นเราจะส่ง `a_texCoord0` จาก vertex shader ไปให้กับ fragment shader เพื่อใช้แปลงระบบพิกัด texture เป็นค่าสีของแต่ละ fragment โดยส่งผ่านตัวแปรแบบ `varying` ดังนั้นให้เราสร้างตัวแปร `varying` ชนิด `vec2` และให้มีค่าเท่ากับ `a_texCoord0` ดังนี้

`shader-default.vert`

```c
uniform mat4 u_projTrans;

attribute vec4 a_position;
attribute vec2 a_texCoord0;

varying vec2 juju_texCoord;

void main() {
    gl_Position = u_projTrans * a_position;
    juju_texCoord = a_texCoord0;
}
```

จะตั้งชื่อว่าอะไรก็ได้นะ ส่วนใหญ่นิยมใช้ชื่อ `v_texCoord` กัน แต่ในที่นี้ จะแสดงให้เห็นว่าใช้ชื่ออะไรก็ได้ จึงตั้งชื่อว่า `juju_texCoord` อิอิ

ทาง vertex shader ก็มีเพียงเท่านี้ ก็คืออ่านค่า `a_texCoord0` ส่งให้กับ fragment shader ผ่านตัวแปรที่ชื่อ `juju_texCoord` ทีนี้เรามาดู fragment shader กัน

สำหรับ fragment shader เราก็เขียนเริ่มต้นเหมือนกับตอนที่แล้ว copy มาเลย

`shader-default.frag`

```c
void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

เราก็ต้องสร้างตัวแปร `varying` ชื่อ `juju_texCoord` เพื่อรับค่าที่ส่งมาจากตัว vertex shader ดังนั้นจะได้ code เป็นแบบนี้

`shader-default.frag`

```c
varying vec2 juju_texCoord;

void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

นอกจากตัว `juju_texCoord` (พิกัด texture) ที่เรารับค่ามาแล้ว ยังจะต้องมีข้อมูลของตัว texture เองด้วย ซึ่งเราต้องรับค่ามาจากตัว libGDX ด้วยผ่านตัวแปรแบบ `uniform` ชนิด `sampler2D` ที่ชื่อ `u_texture` ดังนั้นจะได้ code เป็น

`shader-default.frag`

```c
uniform sampler2D u_texture;

varying vec2 juju_texCoord;

void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

ตอนนี้เราก็ได้ข้อมูลทั้งระบบพิกัด texture และตัวข้อมูล texture มาแล้ว เราสามารถหาค่าสีของ texture แต่ละ pixel (หรือ fragment) ได้แล้ว โดยใช้ built-in function ตัวนี้

`shader-default.frag`

```c
vec4 texture2D(sampler2D sampler, vec2 coord)  
```

ฟังก์ชันนี้ใช้หาค่าสีของ texture จากค่าพิกัดที่กำหนด ดังนั้นเราจะเขียน code ได้เป็น

`shader-default.frag`

```c
uniform sampler2D u_texture;

varying vec2 juju_texCoord;

void main() {
    vec4 juju_texColor = texture2D(u_texture, juju_texCoord);
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

ปล. จะตั้งชื่อว่าอะไรก็ได้นะ แต่ต้องเป็น `vec4` นะจะ ในที่นี้ใช้ `juju_texColor` ไปขำๆ 555
{: .notice}

ตอนนี้เราก็ได้ค่าสีของ texture ละ ซึ่งก็เป็นค่าสีของแต่ละ pixel นั่นแหละ และเราก็ต้องการเขียน shader ที่ไม่ได้ตกแต่งสีอะไรเลย ดังนั้นเอาค่าสีของ texture ไปใส่ใน `gl_FragColor` ได้เลย

`shader-default.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    vec4 juju_texColor = texture2D(u_texture, juju_texCoord);
    gl_FragColor = juju_texColor;
}
```

หรือเขียนให้กระชับหน่อย ก็เป็น

`shader-default.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    gl_FragColor = texture2D(u_texture, juju_texCoord);
}
```

เพียงแค่เราได้ได้ default shader (shader ที่ไม่ได้ตกแต่งสีอะไรเลย) แล้ว เราลองไป run กันดูเลย โดยใช้ shader ล่าสุดอันที่เราเขียนเมื่อกี้

```java
import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;

public class ShaderTutorial extends ApplicationAdapter {

    private Texture image;
    private SpriteBatch batch;
    private ShaderProgram shader;

    @Override
    public void create() {
        image = new Texture("yourname.png");

        batch = new SpriteBatch();
        shader = new ShaderProgram(
                Gdx.files.internal("shader-default.vert"),
                Gdx.files.internal("shader-default.frag"));
        batch.setShader(shader);
        ShaderProgram.pedantic = false;
    }

    @Override
    public void render() {
        Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        batch.begin();
        batch.draw(image, 0, 0);
        batch.end();
    }

    @Override
    public void dispose() {
        batch.dispose();
        shader.dispose();
        image.dispose();
    }
}
```

จะพบว่าภาพที่แสดงก็จะเหมือนกับปกติ (เหมือนไม่ได้ใส่ shader) เพราะว่า shader เราไม่ได้มีการแต่งสีใดๆนั่นเอง

![](https://lh3.googleusercontent.com/3ZkcKwtjL3DgNR7LjCZSvTshaEUEXrUBvMCREkTyYjEopajQoF_M8G3awzB5eLNBwP5uwBwX75c8JibPXmgf6fWBKxe3rIHvcFkelntgOda0OPTUOI98ATg5HJR-1kZBEvWkuHTQl6fIoUqj1ZF4bX6MTc4iWdVhD1EpG5XUk7hoThNaZh9lIW7YUEA1RO0Mfixr-oAmL_1KzjO2Rlu1-8wmeNpd394kzm9KgGT_7KSPmLWmoGw3MAo7NijRb5iS08mSqCdjlQC-TB5YMQN08EjE3X1dTHtxVZwJ54vHYHijLLtvikz1o3J2rvK4hEU7TSjaQH62kwDT_jvHM_4GoVphoqncBZiog34ba0vLaSMSQi6YrDclSgG4j3ABIgeha9zLgoicMxcDw7q1ny2_WpV6aIGzYPAoejqFcVG6VMBQFcUkeXYXxQxJB0XX-ld8L-Ii4kbLFrrUgPfHUm72sJQXEhv6hkUJLB-DAV1FSCbI79vLdO9syFyH-lOr4V3MMyLtzGM4MEfZbSew4wruR27wfyT8MHyUt10aRzxbgqBMr2eUJTA371_wzzPeZuHL6T8XEPyL3WwaFO3vwEVqhQjIZXJzPos5D-mze80pzw=w300-h400-no)

ต่อไปเราลองเขียน shader แบบอื่นๆกันบ้าง

## ลองสร้าง Shader ที่ปรับค่าน้ำหนักของ RGBA Channel ทั้ง 4

Shader นี้จะเริ่มมีการยุ่งเกี่ยวกับค่าสีของ texture กันแล้ว โดยเราจะลองปรับค่าน้ำหนักของ RBGA Channel กันดูว่า จะได้ผลลัพธ์ออกมาเป็นอย่างไร เริ่มจาก vertex shader ตั้งชื่อไฟล์เป็น `shader-color.vert` และใช้ code เหมือนกับ default shader ที่เราเขียนเมื่อกี้

`shader-color.vert`

```c
uniform mat4 u_projTrans;

attribute vec4 a_position;
attribute vec2 a_texCoord0;

varying vec2 juju_texCoord;

void main() {
    gl_Position = u_projTrans * a_position;
    juju_texCoord = a_texCoord0;
}
```

ส่วน fragment shader  ตั้งชื่อไฟล์เป็น `shader-color.frag` แล้วก็ copy จาก default shader มาเหมือนกัน

`shader-color.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    gl_FragColor = texture2D(u_texture, juju_texCoord);
}
```

ทีนี้เราจะทำการปรับค่าน้ำหนักของ RBGA Channel ดังนั้นให้เอาค่าสีของ texture ไปเก็บในตัวแปร `texColor` ก่อน

`shader-color.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    gl_FragColor = texColor;
}
```

จากนั้นนำ `texColor` โดยการนำไปคูณกับค่าน้ำหนักที่เราต้องการ (`texColor` เป็น `vec4` ดังนั้นค่าที่นำมาคูณจึงต้องเป็น `vec4` ด้วย) อย่างเช่นตาม code ด้านล่างนี้เป็นการคูณค่าน้ำหนักของทุก channel เท่ากับ 1.0 (เป็นค่าของ channel RGBA ทั้งสี่ เรียงกันตามลำดับ) 

`shader-color.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    gl_FragColor = texColor * vec4(1.0, 1.0, 1.0, 1.0);
} 
```

ถ้าลอง run ดูจะพบว่าไม่มีผลอะไร เพราะเราไม่ได้เปลี่ยนค่าน้ำหนักของมัน ทีนี้ลองลดค่าน้ำหนักของของ channel สีเขียว (G) กับสีน้ำเงิน (B) ลงเหลือครึ่งเดียวแบบนี้

`shader-color.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    gl_FragColor = texColor * vec4(1.0, 0.5, 0.5, 1.0);
} 
```

แล้วลอง run ดูจะพบว่า ภาพมีสีแดงขึ้น เพราะส่วนที่เป็นสีเขียวและสีน้ำเงิน ถูกลดค่าน้ำหนักลงไปนั่นเอง

![](https://lh3.googleusercontent.com/s7xVeUUCDSCgozW5djMe6beIJEYWEOCa4W5dlT_LwVDMZAOkigp7N0UwEvmNSCKtTBBHcKTeND6670MXYv69EthblpYmCUYGG7P-Re1RrUhMUnQgMrYLuV-bg610ms1hSKlVlAdtDTtjAR15ULkyoD2IMw7n2iJ1cytfXXcsly43TOxvACUWi3DZDT3fauCnqAPYnfTWfYQu8eDDZII1G8uyla3HTlXPcc8xA6LKOUIfHIL8ZnMcVI8Go4TrX4b3cuMMUwe1vytEw8jo9GiSHWMBBnBZJpLZl6C5OEHleBdDDzBXAy6lGPwbxXnI4saV6Iiq3r_t5KC28wF5GHhjHbrrLmmmGUEpBKLe5HErWAnZqnsncpp-uE2oTP7EgwsVzL0Tnmpu_qqXRf0CLdnU7ay7-8NIcwkGSeIxHG0EbBhuFjYHSl7f-_oUUXiA5-4L_6eTppWTGN4-sdfpB-lmPh7QWFiGc_2rjGBuWdEQNcQH-lqG-t3G9nnwOwTa3YmjLqThGEcVViIf5uH2eI3TzVTYQDKsv9dtgC61XGai4a4C-MnhAqoGM91rQOB4EJOy8Nlmipyr4K24U5R1ZPkfmT-HSeuzxR6a7IZvggUfPg=w300-h400-no)

ทีนี้ลองปรับน้ำหนักเล่นดู แล้วลองสังเกตผลลัพธ์ที่ได้ดูกันนะจ๊ะ

`shader-color.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    gl_FragColor = texColor * vec4(0.5, 1.0, 0.5, 1.0);
} 
```

![](https://lh3.googleusercontent.com/69a9cYyCtW43n53ttJOADnC5mpUZZphvUpMzDPmYvRLk-0H-Ka9kYcnIXBk_BXG00RM0ZKvUftWelGHdpb2AC5SLA_vL0iUCqHGU1P5TOzGir6nUBZJbAq7VcimYUtiSMHp20hHgiEKWDEiioRX9_tAdG9P_J2TzqN1rwlZwPJ4_WKgsg1yDjlSJgnQKeXQhx_DIvSFJ9cCCGUA0ePf1_bsiMLWxE0f8JCBu-L6XCC7TgfOFfCCl9XSwuhUYgdXETxjtNpdqh-o6Zau9nEBTr1CPeZTG_PrnL02Ppk0LsTFkAr-F-EzQKXyQjRZG1VFzWLaKgTZglJqKcb_ORsVvPzNxBm9iGYxQsKgypH5jMOSsCgVtR3Ad46BysCq-RrEkA_82GF0nxyTqSARZ4QhCd7ZITE65o5F-aKUtb-afcHEtyd8Cznzw9WDi5FsvboF56WjP-ByUXNFARr5Lth8XVBQEu6DoNtPByGADfj93e3tOq-dAifNrxBSnTVz4LP2MCU-6XtVBngWjZ675FSwOdq3uelvCEXavitVDNCJ23dGGiKNUt0ouTOzKyDLsRqthpKYDtnVOLeKyAmwReXqJSnBu4Kso3JrDmfFUNuLzHg=w300-h400-no)

`shader-color.frag`

```c
uniform sampler2D u_texture;
varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    gl_FragColor = texColor * vec4(0.5, 0.5, 1.0, 1.0);
} 
```

![](https://lh3.googleusercontent.com/k6YEOJumMVK8NNTgyn0c9VGwzo1_nZqNUgctaufqkyVVyYKVCmsTfevppUOszdReMVtlJjsWYF6BZO8HsRMC7nLQ74zjQ6_Kd5VYW1aYfl-Trq4f-Xe0O_paq-e2I4Vid_8zyIqyUeKYiAySV5ZuXPaeLPqIv2MqW5FxpUNALCFX9NzO8IQ6rNEoleNn8eURN-Ruo3jhjeQBt7HK4mm25qbGp4xvc10aTRQoygE8eVtTed3YaOeiDkKLIRgB9mtGb58N4reIrdGGexDT8kWl0cNEMsAaOKznI82VPHXWnfJwiPdAkozBn7WgwGJ75aw2Scol3Ff1SJ0LjviEtFcQlgXjX2LF1jso9G67K2flfA3u5myBYD-wss38F2C6eSVD5FLUzcE_KA3dc74vXPwsdawnRNcyWnayr2C85ZkLSQ9JuaqTvRg8c3edFf9X_E3QKDSwdE7yO0IhuuHLoYHBv43EXaty15MzEZOBb9oMOnVX8e_ezDL6EiiayTNZjsPvYP5cH-cNFipfA-TP4lLuBbHNX0KjBq6e1FUbQ5OpNH1bMf53dn0p2y_F59I0-njG9kmHrAyhFGuN47VA-eBmWymGs-eczHieEPkPrPG2Kw=w300-h400-no)

เพียงเท่านี้เราก็จะได้ shader ปรับค่าสีแบบง่ายๆแล้ว 

## ลองสร้าง Shader ที่แสดงผลแค่ Channel เดียว

Shader อันที่แล้วเป็นการปรับค่าน้ำหนัก แต่อันนี้เราจะไม่ปรับละ แต่เราจะเอาค่าน้ำหนักเดิมของภาพ มาแสดงผลในรูปแบบแยก Channel กันเลย

**ข้อมูลน่ารู้:** Channel คือสิ่งที่ใช้แสดงถึงปริมาณของสีใน Channel นั้นๆด้วยสีโทนขาวดำ ยิ่งเป็นสีขาวแสดงว่ามีสีใน Channel นั้นมาก ถ้าเป็นสีดำแปลว่าไม่มีสีใน Channel นั้นเลย ดังนั้น Channel ของสีไม่ใช่เป็นภาพสีนะ อย่าสับสน!
{: .notice--info}

สำหรับ vertex shader ตั้งชื่อว่า `shader-channel.vert` และเราจะเขียนเหมือนเดิม 

`shader-channel.vert`

```c
uniform mat4 u_projTrans;

attribute vec4 a_position;
attribute vec2 a_texCoord0;

varying vec2 juju_texCoord;

void main() {
    gl_Position = u_projTrans * a_position;
    juju_texCoord = a_texCoord0;
}
```

จากนั้นมาเขียนตัว fragment shader ให้ตั้งชื่อว่า `shader-channel.frag` จากนั้นก็เริ่มเหมือนเดิมก็คือ ดึงค่าสีของ texture มาโดยใช้ฟังก์ชัน `texture2D()`

`shader-channel.frag`

```c
uniform sampler2D u_texture;

varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
} 
```

ทีนี้เราจะลองให้แสดง channel ของสีแดง (red channel) ก่อน โดยการนำค่าน้ำหนักสีแดงของ texture มาเก็บในตัวแปรก่อน
โดยอ่านค่าจากค่าทศนิยมอันแรกที่อยู่ใน `texColor` 

`shader-channel.frag`

```c
uniform sampler2D u_texture;

varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    float red = texColor.r;
} 
```

**ข้อมูลน่ารู้:** สังเกตว่าเราใช้ `r` เรียกดูค่าทศนิยมตัวแรกใน `vec4` ไม่ได้ใช้ `x` แต่จริงๆแล้วใช้อันไหนก็ได้ เพราะใน glsl เราสามารถเข้าถึงค่าตัวแปรใน `vec4` โดยใช้ `xyxw` หรือ `rgba` หรือ `stqp` ก็ได้ทั้งนั้น ไม่ต่างกัน แต่ไม่ควรใช้ผสมกันมั่วนะ!
{: .notice--info}

ตัวแปร `red` ในตอนนี้เก็บค่าสีแดงไว้แล้ว และเราจะเอาค่านี้มาแสดงในรูปแบบ channel (channel หมายถึงภาพโทนขาวดำ ที่ใช้แสดงปริมาณสี คือส่วนไหนขาวแสดงว่ามีสีแดงมาก ถ้าส่วนไหนดำแสดงว่ามีสีแดงน้อย) ดังนั้นให้แทนค่า RGB ของ pixel ด้วยตัวแปร `red` ได้เลย

`shader-channel.frag`

```c
uniform sampler2D u_texture;

varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    float red = texColor.r;
    gl_FragColor = vec4(red, red, red, 1.0);
} 
```

ข้อสังเกตก็คือ ถ้า `red` มีค่ามาก `gl_FragColor`(สีของ pixel) ก็จะยิ่งเข้าใกล้สีขาว แต่ถ้ามีค่าน้อยสีก็จะเข้าใกล้สีดำ ซึ่งเป็นลักษณะของ color channel นั่นเอง

เมื่อลอง run ก็จะได้ผลแบบนี้

![](https://lh3.googleusercontent.com/DyYPiW-SHBZlwK4bq18ZQcvqpVrA0nHWj-ZX-O9_4SQESelBN8QddACVXiQdN7R4yzigGvXQXwx6k8uQr5PSd94TAO0KvoXz0_TsI6Kdak_pZLXonNkecWRASieWTS4o9_laVxEoYVZgG1pdPTo88HHiMranvNZOnQXCU6QTerXwUT8jQxleT0a3HEizRzvEAG7cjFHTor7n9N_Um9hphF1oc8lTJbT9MdhmW0TduHIw4HYu9wMkgBZCA_SFBjZCW0L8B8EIHWRJe10YJILneb8Ezi9Xv0w6l0zzEuwoXPcxaDY-5etrmCAKC7aTSlX9jCMlAust4J5lmnsNboo70Spou0FkgiL9K3LoGGk17_lO6MHHfooUrViDbvbS-GhLd4O_8tTkO6TizYl4a_wsXjqrO9InNsqz5hijlQVzBEbfFgq3Y476c7nuxK-PN8z8TLrwRlfox9ZtPx-H-pblItsdep2Z3Cz-5zraCOV3rzULKqdm45XcCgO_NtTCvVBWjepjTdglWDb6kWkz1ovGUr3DRQYv4ue-k_tVbmPDMCo_7agK6ZkBwV9CACk_Ahf2t25zKpsPYa3vV8huUHAQHvrWAHeiLSUEl7KpTak7Lw=w300-h400-no)

ถ้าอยากใช้ดู green channel หรือ blue channel ก็เปลี่ยนจากอ่านค่า r เป็น g หรือ b แล้วเอาไปใช้สร้างสีแทน แบบนี้

`shader-channel.frag`

```c
uniform sampler2D u_texture;

varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    float green = texColor.g;
    gl_FragColor = vec4(green, green, green, 1.0);
} 
```

![](https://lh3.googleusercontent.com/wlbHQPXEJfZSCZzmu04puKnD_8utC5iSajFHwrQOPzDmDklrzDWS2E6aQyscw39196HPtFicuQOL_oh5SN5fgEe9rDR-tz-nng6kHoWQEkiznns8Q_acU6Fs0NsivjD29uTDFgg9PctvAOZApKRSUeDxCOTYfMc8mpwvP7grUMeKhbX2nij3Rs_7kF7MPls48SGTrpM8_SghtTqllR3MYfIwdtmwd844rKkv9DBhcceOSkzydwhZuM5s8hFJ42IoUAmXXq_7brkfKJheFbEXLAcPFeYXfUbqO6XXSJAO3Nh3zUTXgstyVDINgXVYRQOCbEDDGoLwGqqlPW694AtZN1SDCohAuN4d3bP80myjUJ0bJLV7czHBGxhquNWlWCnhpJGCB8r57iNJ4l1NuvZWm282JL6Y_HkY4F56fnSODA6KyOJxeLQ3a6fze25mj7N0ZWBUzWolTg6dSPdlARIfdP5ca1rmc2x7GJ8how2R3kaGdPs3wah8bOZUsThweI4nezCi44deQtJDHJjkxRzBrz41_ke-WmNXolvnw5TAElf7THGWXNaFGoB_MFkdfNhdNDIaeqiWHN87FpQ1zcz7nHnkUv-6EwKJovelB9rtvQ=w300-h400-no)

`shader-channel.frag`

```c
uniform sampler2D u_texture;

varying vec2 juju_texCoord;

void main() {
    vec4 texColor = texture2D(u_texture, juju_texCoord);
    float blue = texColor.b;
    gl_FragColor = vec4(blue, blue, blue, 1.0);
} 
```
![](https://lh3.googleusercontent.com/wHeSKWeLRhNvlEoeg_nGhE4kEPXI_MJz59vF6Lgn39NBfoO7XfKGAlNVdZ8nCxqpzahPa6xcZnIt-ggiEne1Gwtc6aWMwGEUyMbqLIIsgyEGrssrQ1l5iYQh9FKodsUT_4Oq4INysp5aTZJfhCAohAjkUnvuqrTUb7lFgwwsPTMACKWJTB42LUcDqGERqF7dvgpiCDfcV0Hy3c85odXdsX1wnyijCKNcZmz6T2qj2UDZTD2Qus2gnAO0GpKC5DpNZofIe-GgiYG3uDt8EY8ZOeJLsKbxy_WhUijdM7Ywi82u1iffQg_G5Vnejzo7-jSQrYCo4drWI_lUF6V-pWVwKqpqaZb6H66g4Cjsgoyb4-ZyvNqHLitjCqXTRW6IjiTR2u8mvvUEbwIr4Of535sL2xTXh3qfg-s59XE_HZGRZuWh9e7vAuj5IUiYmW3_CXO-9hdjsWIe1p8qf4aB4vpnG7j76_tqNM9H8jLt44Qfqebkum5dXoWmjrA2jBl5bVvmCmyd8NiYNP4gjZPxK7MxcB0G1A4huUAYhj8Wo3z7ozknxFGy9CCuko5LHbotK3-8v-Mbrsi95xxe84NOwDxOxWTBBZwq8abxWILHlSWD1w=w300-h400-no)

อ่านจจะดูว่าคล้ายกัน แต่ลองสังเกตที่โบว์ของชุดนักเรียนที่มิซึฮะใส่ดู 

![](https://lh3.googleusercontent.com/3tL1mL6aq_DagrcQ6p-ulYsK-yLes7XwiKof9WgJa_1thF_pTleeFK1EtJ2_VnKyqoCe7vg_zXvuL8EA014VtDJkNQERKTqbY4UrKICD3_eHRkqr35H7RZF_Nspe0G1_UsTZN-UXhSYvnnHd9bmn9-DlEHX6bdEeY6R2GyXnGTXwnOAJOkK3ZFUZQVhJTqFS-P-S0C_1Wfvd3oYHsC4G4wazOXnyOGyWArLUJqi2kVCwQlrMUVJMqPuSALkDBbeFS5ZhlOR4SBZQ2ZTDmFj9hXC1uR9t8nFqePf3I1l0Jb8_Oj1YICIyOJ_hs64Ivw-_mQjB5qu-ICTgH1oPFwwczNU8p3Hgva1eVFSd5F_g-RHoIOc4whJOJcXYP8iv0Br2ASJn0Txg66hk6tHWJP3SGygaB0OfC1cS6bm9rEOlGeM4j3lKAX4663omwfUBNfdjTipnxMXRdO2cHN7FQzyDh-RiX6vpwkjgrj_Oe1EZT1dDgQ5iJGEh56lNG2vamt1zepezw74V_VG_CTmQFzK0w4RW_ZkB7tg7xuqJ6EcPjiRlGLmH_nui6CpWIwupQPR70gk3lMX8Rh3ymBjxtqXM-pNIDZUF-Fyi2eesO1n8jg=w504-h662-no)

จะเห็นว่าใน red channel โบว์จะมีสีสว่างกว่า เพราะโบว์มีปริมาณสีแดงเยอะกว่า หรือถ้าดูลายเนคไทใน green channel จะมีสีสว่างกว่าเพราะปริมาณสีเขียวเยอะกว่า

## ลองสร้าง Shader ที่แสดงสีแบบ gradient บน texture

เราจะเริ่มเข้าสู่โลกของ shader กันมากขึ้น โดยในครั้งนี้เราจะเรียนรู้เกี่ยวกับ texture coordinate หรือระบบพิกัด texture กันผ่านการสร้างสีแบบ gradient

สีแบบ gradient ก็คือสีที่ไล่ระดับความเข็มไปเรื่อยๆแบบนี้

![](https://lh3.googleusercontent.com/MY6j-oxK4SNMioLi8tFVxeJXg6d_5qTwKlg4RHIBKmvW010oyG2LCG3iybRzyhw1mriBHaqU8Yck8IMQyiAF7czh2F-yTz42flJgAK_-ucr8XirUgSzTQIQ6JOqLWQ5xPeRHmJN_bWRKumAPEd8OVy42KNkz5jrhuntK2FofnTraQLCffWnNOSK9lbBYAnP_46V7QyJs542r4Pc97wQNQUzFUSHhgGsXSwx6jQ9XwZ-OHlDzpieeBhOoOf0ZNCNoUA5BX3Iw_dhGNrc52M8P54K475DAp0wLS4C6_mGPCHxFEDRTRJ895vmDRnveRn2wiOjVorHvkVQYmD0pwDVzaIL-BtcsZrqQ9Di0CTiNqMAsKDiukFREqFmbf-1Q1jiBMsQDwKetiIcJzoDX-1fQ_vo9y9cOU85rar0y9itVlIwcYwvFII787rIVpSUqm7KuOZTws_HwZLXCevR8uM88R0I96n-dBdeuqUXAGGGJnEcSNjfJa3Wy6khzu3eg4SiNafsTzgxkKk6ilS8mp1xFrd4cUPvSqr5YyxXkX1UFQ-5TP_pVFabsvJ4rdNY92X9GqW8cBiY7b03val7vTGReffJDkm22cg5QNYrqfEX09Q=w633-h176-no)

สังเกตว่าในการไล่สี เราต้องรู้พิกัดของ texture ด้วยถึงจะทำได้ เพราะถ้าเราไม่รู้ตำแหน่ง เราก็ไม่สามารถกำหนดความเข้มให้ไล่กันได้หรอก งั้นมาเริ่มเขียนกันเลยดีกว่า

สร้าง vertex shader ตั้งชื่อว่า `shader-gradient.vert` และเราจะเขียนเหมือนเดิมกับอันที่แล้วเลย

`shader-gradient.vert`

```c
uniform mat4 u_projTrans;

attribute vec4 a_position;
attribute vec2 a_texCoord0;

varying vec2 juju_texCoord;

void main() {
    gl_Position = u_projTrans * a_position;
    juju_texCoord = a_texCoord0;
}
```

ทีนี้มาดู fragment shader ดีกว่า ให้ตั้งชื่อว่า `shader-gradient.frag` และเริ่มจากโปรแกรมเปล่าๆ มีเพียงแค่ตัวแปร `juju_texCoord` ที่เรารับค่ามาจาก vertex shader เท่านั้น

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {

} 
```

กลับมาดูรูประบบพิกัดของ texture

![](https://lh3.googleusercontent.com/hDgBZwf2am9DV6TGH4AhgyiRF4UXMy8OF_pOHbxIMOG8Kqw4I2Cu0ZZBNr9zD5sZNWFsepjAX9SJtQMPzSjY5chjjO_Qf8vwK4wRv7Z8G51jNJhgwJtZpgQ0rSCX5j9yIUtSXPUSt4ppkMSMGke-KcHu5oNwFxEbxD4j1K0xAoC-ntCygvItCLimO-HLMrPWHR11-3UIjZNvdyLBBJo8fqwb298tZlbaYwz-7bxz_eOa_k_BRw3oyUwNhM813FKI5Zs3gwFqeQ0zpTFDGYL065ZousILALl_vWb9yz4Qf830OYBn-kn1kGQKJGTOMlHPBLlh_BTYUgFfWe03vTvduEe1C-o2KET19xmkkTyZquOHv5vTqaw8xfiMQtV9Wqkn1ZDvAbDb9JeKiNQxkAYCIGP0eEQ-hKTqBQfBG1A6Hs22CBMxHKCGFdGxefyKR9sCa3ksG8txywQ4OwAYf5ctVL28BCWSBeO9Q9F5QA3cA0jK2ZgbpbCp0GC_EL3s_a_st8Okd1Nw_yVQzjVGU1IejJw9Cxn_92WSNLJVl2t01n7U5PIn40RMNAhH9bheCqv_Gie7E6Y-bLCLbJr62DSGgSrr8vEJCqke6NuC52cwVA=w365-h398-no)

จะเห็นว่า **แนวนอนเป็นแกน s** ส่วน**แนวตั้งเป็นแกน t** โดยทั้ง 2 แกน**มีค่าระหว่าง 0 ถึง 1** (ดูที่ค่า texCoord นะ) โดยที่มุมซ้ายบน จะเป็นพิกัด (0, 0) และมุมขวาล่างเป็นพิกัด (1, 1) นั่นคือ **ยิ่งเลื่อนไปทางขวาค่า s จะมากขึ้น** และ**ยิ่งเลื่อนลงล่างค่า t จะมากขึ้น** (ลองสังเกตดูตามรูปเลยครับ)

ดังนั้น ถ้าเราเอาค่า `s` จาก `juju_texCoord` แบบนี้

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.s;
} 
```

ตัวแปร `value` ใน code ก็จะต้องมีค่าเพิ่มขึ้นเมื่อ pixel อยู่ทางขวามากขึ้น เราลอง**พิสูจน์กันดู**โดยการเขียนแบบนี้

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.s;
    gl_FragColor = vec4(value, value, value, 1.0);
} 
```

ถ้า `value` มีค่ามากขึ้นจากซ้ายไปขวา สีของ pixel ก็จะต้องขาวขึ้นเรื่อยๆจากซ้ายไปขวาด้วยเช่นกัน มาดูกันเลยว่าเป็นจริงหรือเปล่า โดยลอง run โปรแกรมดู

พบว่าได้พบลัพธ์เป็นไปตามที่คิดไว้ คือภาพ fanart ของเรากล้ายเป็น gradient ดำไปขาวตามรูปนี้

![](https://lh3.googleusercontent.com/cJQ-P3Zus-flcOIffj9f6ouYAudZ2K_AQpeeDG5AhVqR2JLZh3q90Bffds1qKS9ZgG4Q9NB4CeKJ8lYAMTUa3-YylEY58Ylk_Y__ZbI4EgUqLPiRJOB7fbiNQgc44mMWj7C_-NoRLMjAx2Po5rit-8M_wL0ZZHpVog1ilT10PREp90vb2EQJDy7ikf8xmruqHrK1zdh5vlWbQZ2U-_vEDo12oijvaywM2uXg4CIHIeXcenuXL_n88_M1ijU4V9Lz5pPMNZy43zZK2TCXsKTNheCVI4gH3u1ixRYYGQI56S_qGlzvFo0CIAG-5mp9uE5YLVIKuuUMlNqFE2EgiAyDMKffRR7DN55frqeFnvUv84BIghXXeu_D1BMnbqzrw6eMsBR3niOVFYWnPbwSf4OHArFK_vbLcvHdpcYwChi20JowMMaPR0x21SP1pTBBH5QTS3821GWNm5Pl3R5dVgO5OvvYjynebwlD8KfWx1Mty3mXtK331Lw5eTX9KV174t1XWuEUqalUQpuszwPB9D5zy_mryoVTxtZMUC6vsguCMI4BOiy4T6oAWKJu0DZgDvZT14lWbp9zOTgfnRCqzIOMGkVytqvRt_5hXcDArISSvg=w300-h400-no)

ดังนั้นแสดงว่าค่า `juju_texCoord.s` มีค่าในลักษณะนี้

![](https://lh3.googleusercontent.com/rJtDAxweM-1KmbWC1hm5cX71fLGiSkqzQZDVBSBUdYyh0OtZnuj2-Gs3S_qR7MVCJm_CgomiMPnIZdXeGLfso3zThUMNyzmUvYKRG4V-qz4_05cUWKiazRHIdyXq6RsjsmVcOfoNcvSIWG640XHSN11hhOyYHR87VZuklK-TggbS6YCJjFLPbOuy8zJgoU8-AUMfnpEZYF25NdpB2-S-e5cFMHwVTFsMbvz3I4QWQqQg0CtE6a-GmRDEJTgeqIk134Cq4al6tcZpJUOy5ybBgSBi8toUP1qHb7g3HbSxL8N6mK96WZ1avnSVkbv6gVOVFhc1-gSM2c1RjcWQBQLowkZR1g8VXDW8BMTVw4Hjfaxg1vGvmv839eIe5mYHabmwoi5-o9BFrYuo1KioU21zysAXU9GK7By5UlugSdsgdOVmXaOYzlDVf_dEXeUGpWhQ6VOdNIFZdfP2g4XL-uanlu1r6QnRv4jiTF_tXuodeAU8l0tZ9Zlt5rlfg7HTKKX0KnmobHf5i9GuMD0LakfYl8PnYgp2CPWIN57_iPD_XDTpvtjU_mMxyMgrva5VzcgPxy9FGtSBu3ztGLSlnis6YEiyWy101O36-VM2x4H0-g=w375-h513-no)

ต่อมาเราลองมาพิสูจน์ค่า t กันบ้างโดยเขียนคล้ายๆกัน แต่เปลี่ยน `juju_texCoord.s` เป็น `juju_texCoord.t`

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.t;
    gl_FragColor = vec4(value, value, value, 1.0);
} 
```

ก็ได้ผลลัพธ์ตามที่เราคาดไว้ก็คือ ค่า `juju_texCoord.t` ยิ่งลงล่างยิ่งมีค่ามากขึ้น

![](https://lh3.googleusercontent.com/CRy-iReYptLigwPDfmygrwm6QswvtnmEbduFHcnKzFuZ9KtBCc1stup9sp6MdF8jSsA87LNkB0HYho5k6bitBJNIiOH1AkWaTsHmhqZO78372vvzVciM0c2VDFLG_qUDnyW2lb1vafkDH4k4x1dSmoJeyLlFljQFYMMKBr_skmQkPv-FB2yc_LMEOKS2ikA050_0kOu7M0jd56bLD3CofUtXo45-vjSxTTdao2KxDoCJH57iYpzO8uCkOKmbgaSUtHmvuyek0i7UKGwIVTSNpdDVOgzgGfLhr6neCqZBhWbYuf8ROzklorl6wN0W8BxNwpgLD1AXTdehT60bA4WhDPT9UmZ7WNn_--VgjQn5KAM84NoP709cWVRf8QhdNnZzfRv34ZkIEIlVFcyJC6afc9eG64PIP-gdd7dRuYzKPXWs3YSHs-hsEhEp91Gyr0FBUBCG8fRO9GZ-P7JCNphEpz5ZnPrzr9MSsGgOPDuWLQGIwmE3Bor3ghLMzQWCD1U82ALXVFA0oWhatEZpCh7MURnovr2ywsX47IB0FdXLwtSeEu9WLYWHN7JPOLk0Fbl4x51jZ4_0mvTj_1ukW4kROO2v7ZEkUROTXXrl05HzzQ=w300-h400-no)

![](https://lh3.googleusercontent.com/c9nRCvWFKR_tENPxj-bn7eUE1tQK3Oe7PVQnekHJka3EcS9QMJUWdaitzV9NPFG4GQjnGGqf7Wv8wFroWL1I63tSESM7QX1suP-HjFxgI6qIoOQAN5GSOdUt6VqesO-k8KVS4mD3qRi018GzX9vM5twpzTNtEIijKdEcqTCgwc4YfWXVQGbzNrxZe5eDM5B9CuMHAvycpkBO3_eTn2AZaf7NOK_FDNEbSTkfMCTBsNpkA3bjkpycEPdjWDEn1ycZOK2e2gW7UJGB_sAYWexYFfNGQloIYxrLa_DJaX24uPwMlkLR-GGwy9omCW_UpkFpmTaMpY8tygd0nFKI9Pc_WC9B2O8kF_xxDWCLPjzQrHJI1YQ7ORzCqXIJWq0EnNPXSucs5gE_YV4N4s_zCk11DwmOZsKuQ2dDZCTt45eIiCMqc49-w73oQ-uSKdCNshR_PGD1lvq982aJ5x6Wc6y6C2Ly9XOZo1wXhFDY0SHa-fcGo1PC_dUgLSB_m_3aQ0ZGiYTCFGmtTLMUUcPPC8AlirKqSyIWHpZfu6MmlLInMsS1ojLlum6LP8MF_Comw_IE8D6rpqyUQUJtx5N_juWATzUEO8ZB0xc4968EjRKSiw=w391-h480-no)

ในตอนนี้เราก็รู้แล้วระบบพิกัด texture (`juju_texCoord.s` กับ `juju_texCoord.t`) มีค่าเป็นอย่างไร ดังนั้น เราสามารถประยุกต์ใช้งานในด้านอื่นๆเพิ่มได้เลย งั้นลองเริ่มจากง่ายๆก่อน เอาเป็นเปลี่ยน gradient จากสีดำ-ขาว เป็นสีแดง-ขาวดูดีไหม? 

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.s;
    gl_FragColor = vec4(1.0, value, value, 1.0);
}
```

ผลลัพธ์ที่ได้

![](https://lh3.googleusercontent.com/vskNOv3F2ZuPJ4uagYfXrsw5aeOvdQCcy5X9kNppXBrs9K8OhjzLAWFn5uLemA19gTl0XQU0BVCS1rMuHfRISEaFLW0L7g9VI1tsZanVsYXeCsQgAUB-5jgB0pNVlPHJ_WfAiKM2yQJ9h7zTGO0ce2WlLYYOQQgEsIq4cL_SnGMY7BNQnwnRQg5yDmBXrEG7XYyG8QeIqSlw9k60FhasZNhr6Cahn0WgLf5ZDvIzk40zKseoTLgj2lQdv0JUsYi7tjxUVcsIiTuV7xR57OJfKrHQubzO9Xrr3OOCGNKFeW8Jj7JFJB_yo6P0-liMTebWG4GCfEcYRRr1lftc0Wvii8iD27M69bIz9R93NZvqOzuEj9czXeC2VXUexGQDsCVb0-8GGU3IMwpLIj3RpNThwpuA59rSnBrJSDTnTYriy059200dHqgJqhLo3m9lSuFoX8pU5X9be9J1j8WepbdGaih-CoyorBQZYxnTJRR04noM-DgFc2Qu4BM7n3GqXfS6RBzPHkPzG10sxAJBSJ2NQdk0vCWmJpalQgX9LZDPoDDhgmG7kEfvujQjm6n8GvErojpyRV3QOiaFbwJFg3DqgzHDr_ZufB1QLI_BzGDENw=w300-h400-no)

สังเกตว่าถ้าอยากได้ gradient สีแดง-ขาว ต้องให้ค่าสีแดงเป็น 1.0 ตลอด แต่ให้ค่าสีอื่นค่อยเพิ่มขึ้นแทน ซึ่งมันดูงงๆ เพราะไม่เห็นมีสีขาวเลย และไม่ค่อยสะดวกไปหน่อยนะ ดังนั้นลองมาใช้ `built-in function` อีกตัวนึงของ glsl ช่วยกันเถอะ ครั้งนี้จะแนะนำ function **mix**

```c
vec4 mix(vec4 x, vec4 y, float a)
```

**mix** เป็น function ที่ใช้ผสมค่าระหว่าง 2 ค่าเข้าด้วยกันแบบ linear (สูตรคือ `x * (1-a) + y *a` ) และนี่เป็นตัวช่วยของเรา โดยเราจะเขียน code ใหม่เป็นแบบนี้

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.s;
    const vec4 red = vec4(1.0, 0, 0, 1.0);
    const vec4 white = vec4(1.0, 1.0, 1.0, 1.0);
    gl_FragColor = mix(red, white, value);
}
```

**ข้อสังเกต**: มีการใช้ keyword `const` เข้ามาใน code นี้ด้วย หมายถึงเป็น `ค่าคงที่` นั่นแหละ
{: .notice}

จะได้ผลลัพธ์เหมือนเดิม แต่ code อ่านเข้าใจง่ายขึ้นว่าเป็นสีอะไรผสมสีอะไร มองปุ๊บแล้วบอกเลยได้เลยว่าเป็นสี gradient แดง-ขาว และถ้าเราลองคำนวณค่าดูจะพบว่าเหมือนกันกับ code ที่แล้วเลย

สมมุติให้ s มีค่าเท่ากับ 0.75 ถ้าเป็น code แบบเก่า จะได้ค่าสีเป็น

```c
gl_FragColor = vec4(1.0, 0.75, 0.75, 1.0);
```

ถ้าเป็น code แบบใหม่ จะได้ค่าสีเป็น

```c
mix(red, white, value) = mix(vec4(1.0, 0, 0, 1.0), vec4(1.0, 1.0, 1.0, 1.0), 0.75)

คำนวนได้จากสูตร x * (1 - a) + y * a
r: 1.0 * (1 - 0.75) + 1.0 * 0.75 = 1.0
g: 0.0 * (1 - 0.75) + 1.0 * 0.75 = 0.75
b: 0.0 * (1 - 0.75) + 1.0 * 0.75 = 0.75
a: 1.0 * (1 - 0.75) + 1.0 * 0.75 = 1.0

ทำให้ mix(red, white, value) = vec4(1.0, 0.75, 0.75, 1.0);
ดังนั้น gl_FragColor = vec4(1.0, 0.75, 0.75, 1.0);
```

จะเห็นว่ามันเหมือนกันเลยครับ ดังนั้นควรใช้ mix ดีกว่าเนอะ

นอกจากนี้ยังมีความยืดหยุ่นกว่า เพราะสามารถใส่ค่าสีได้โดยตรง เช่นถ้าอยากทำ gradient แบบ [uigradients.com/#VelvetSun](https://uigradients.com/#VelvetSun) ก็แค่เอาค่าสีมาใส่ในตัวแปรแบบนี้ได้เลย

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.s;
    const vec4 color1 = vec4(0.882, 0.933, 0.765, 1.0);
    const vec4 color2 = vec4(0.941, 0.314, 0.325, 1.0);
    gl_FragColor = mix(color1, color2, value);
}
```

ผลลัพธ์ที่ได้ก็เป็น gradient สวยๆที่เราคาดหวังไว้ :D

![](https://lh3.googleusercontent.com/gwhCwvd-EzA8pBRPF16Zv17XIS857mgpiMGeYSgbSywzIUH7cxJjISt4bsbyeAqP6G36OMYjhBKhO1rBztMADVeZjebpnBNaalFPkbIoIehl6EvkXFsrucDWgfYIWx25-TukTZ_mcVlfcfkQiQItYclycKoZAkl-AR0JI9qGIZyr28Eir1Ir4xKC15EbQtB73PWE9Qqerfwaec1pIXgZ-fTtN-nQmbAb6FTq_qBQOPqPjmy2ZssdzOExRi86gbw-mavGUiM-_tGSjJ0ysjrXK_CsSUeCIXslfuaD3YS5yU-rOmT1XUhoLui-HWMfyrsNxZo0U3txxqR930ngZ3sSJi_tj-bdS4Yc9Pm3_Qommks1I45EW99NpDAMkOZTWCyA3-e4CfQdkEjiWoZHIPD2bVoeRiIlQLOnlB4gyBmcajj1s3dgMJS4Lq8bJ27Bx2LCEvXRds6L0b7jsHup-qMh-RYmCOR0TdeTcl4Oq6lIGvpyhu5fuI9qfd9faTFoHIriVfGC5QSs5dc9Mq9RKSqsnAtaDBZE8-pBz_aG7VXRC_QXc51B0XhyTaRU_zcYC39gjzOzxyiYJTa1_NK6h9TLKe5tVIc0ns7EBZBxYWhdOg=w300-h400-no)

ลองเขียน gradient ในรูปแบบอื่นๆเล่นดูครับ อย่างเช่น แบบแบ่งครึ่งบนล่าง แบบนี้

`shader-gradient.frag`

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.s;
    const vec4 color1 = vec4(0.882, 0.933, 0.765, 1.0);
    const vec4 color2 = vec4(0.941, 0.314, 0.325, 1.0);
    const vec4 color3 = vec4(0.0, 0.765, 1.0, 1.0);
    const vec4 color4 = vec4(1.0, 1.0, 0.11, 1.0);

    if (juju_texCoord.t <= 0.5) {
        gl_FragColor = mix(color1, color2, value);
    } else {
        gl_FragColor = mix(color3, color4, value);
    }
}
```

จะเห็นว่าผมใช้ `if else` เช็กตำแหน่งว่าอยู่ครึ่งบนหรือครึ่งล่างจากการอ่านค่า `juju_texCoord.t` และนี่คือผลลัพธ์ที่ได้

![](https://lh3.googleusercontent.com/30QI-8jZ6k13FVzPb50xq0Mx3eVQmoB1ptaCoKt_L3Xx2K525XeVJTQ7Bb5aGh57g0XmkWEA1g8kZ60XgzFq_0gOUN4NvOGE2MDjVFA0gzz_dfxvafOvGY_yxgD1wJLQRC-atRhvQgyI5wTUiCdZJzujw3YQmjH4mZoxupIoiwuiy45uFqQ7xkntRhn3VCmcEA7hLoOCVYgn5wiTBNsAFBJgc2z_HzDZ7KE9nQc2C7mmGxbkeWIucBWj8tOPWSP79yhTsYn9dDSbdRA2LXriKmtqOV2PjdVAmCZkKr2ouTDLXKspz5Ipj2UUIhTPPCCHPNK6dBQZf1q5yvJQ5APgZXq3B2R0Pm2mD0mlHcQdPOnQ7cpCyUHyDb0le0boFfa60A7rpU61fvOIfWuuMNHnG_0MQ9uVXeGleDdx_hE7j08xY1mx79UIkw3jsA51odyGezeeDv3w2XdMUhPJioFPgxMp7k8Io4yoeSn7DICvhj4T_EtH0beCR169mNHp-UgKbT7na2GwKIVOUQLdmIIc1_ANIa4-TBmbjDY-31-G9vI4Vlo3oR6gAH4xJO0vTFS3tOiixyG_fOKfeASEbS6kqCOyojsDn0J8WQKQZ_S6gQ=w300-h400-no)

หรือจะลองเขียน gradient 3 สีของ instagram แบบแนวตั้ง แบบนี้

```c
varying vec2 juju_texCoord;

void main() {
    float value = juju_texCoord.t;
    const vec4 color1 = vec4(0.514, 0.227, 0.706, 1.0);
    const vec4 color2 = vec4(0.992, 0.114, 0.114, 1.0);
    const vec4 color3 = vec4(0.988, 0.69, 0.271, 1.0);

    if (juju_texCoord.t <= 0.5) {
        gl_FragColor = mix(color1, color2, value * 2.0);
    } else {
        gl_FragColor = mix(color2, color3, (value - 0.5) * 2.0);
    }
}
```

ผลลัพธ์ที่ได้

![](https://lh3.googleusercontent.com/ZLWC5ladu6ZLiigw3uvH34z3KDfkk49SdfZqD_B66QObC1XriEsqrRdDlZa7wBw1CIW2hoMIIOI7XNxNgsGj9JoMw1C36ujJPGwkLRsLtkQJwHW2iha9W56LRnjkgazhWwBdoj61hxW9B8-p_FT1WnB7jq0l7OlLQtCeNJ42cd00uEkhHIRydJpd9Awn1o0KX48-cxE7jdbMhgPS6NYYJDlu364gELPv-N05qhHaNQzRrhc6kTl8ibYgfaKJbNgnJYWdcBSDpihEsEg-iHklMJ3Ny0EWZpxPhTciRfRHcUrmAbRJoQ4WYKPS1CvJwsugdexPsWAswoA22adRFheN2cyRm5P5VBzGH5YmtelQMQGGbT9CMg41kmOmC_-TCjXjlcZUlEkzpk_WHei5qx0urRYb3b1NzTbj0pp1eEjPLV7cPNorRe5d8sqiVlh21me6LHGceGJeBZHYDT5w5omWJ3S6Ef3y1qqYBxHxd-1OZkyLrimIA3NER_iXf8wpsBAuDdWQp_ROt5NXAqz-AwdR2Qb1CwhlfEYxw_hgy_XOdBkBPujXGd8VYh2R-SBY58TSq-hhVJi6kusoyMX4bFR130jbPcJAiLWXNWP4EHu6-A=w300-h400-no)

ก็ลองไปหัดเขียนเล่นๆกันดูนะครับ อย่างน้อยต้องเข้าใจค่า `s` และ `t` ของระบบพิกัด texture และเข้าใจ output ที่ได้จาก function **mix** สักหน่อยนะครับ

สำหรับในตอนนี้ขอพักไว้เท่านี้ครับ เดี๋ยวจะเหนื่อยกันเกินไป พบกันใหม่ในตอนถัดไปครับ รับรองว่ามีประโยชน์มากขึ้นเรื่อยๆ รอติดตามกันได้เลย ^^